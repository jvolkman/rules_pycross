"""
A tool that invokes pypa/build to build the given sdist tarball.
"""
from __future__ import annotations

import fnmatch
import os
import shutil
import tempfile
import zipfile
from contextlib import contextmanager
from pathlib import Path
from typing import Any
from typing import Iterator
from typing import List
from typing import Union

from installer import install
from installer.destinations import SchemeDictionaryDestination
from installer.sources import WheelContentElement
from installer.sources import WheelFile

from pycross.private.tools import namespace_pkgs
from pycross.private.tools.args import FlagFileArgumentParser


def setup_namespace_pkg_compatibility(wheel_dir: Path) -> None:
    """Converts native namespace packages to pkgutil-style packages

    Namespace packages can be created in one of three ways. They are detailed here:
    https://packaging.python.org/guides/packaging-namespace-packages/#creating-a-namespace-package

    'pkgutil-style namespace packages' (2) and 'pkg_resources-style namespace packages' (3) works in Bazel, but
    'native namespace packages' (1) do not.

    We ensure compatibility with Bazel of method 1 by converting them into method 2.

    Args:
        wheel_dir: the directory of the wheel to convert
    """

    namespace_pkg_dirs = namespace_pkgs.implicit_namespace_packages(
        str(wheel_dir),
        ignored_dirnames=["%s/bin" % wheel_dir],
    )

    for ns_pkg_dir in namespace_pkg_dirs:
        namespace_pkgs.add_pkgutil_style_namespace_pkg_init(ns_pkg_dir)


class FilteredWheelFile(WheelFile):
    def __init__(self, f: zipfile.ZipFile, install_exclude_globs: List[str]) -> None:
        super().__init__(f)
        self._install_exclude_globs = install_exclude_globs

    @classmethod
    @contextmanager
    def open_filtered(
        cls, path: Union[os.PathLike, str], install_exclude_globs: List[str]
    ) -> Iterator[FilteredWheelFile]:
        with zipfile.ZipFile(path) as f:
            yield cls(f, install_exclude_globs)

    def get_contents(self) -> Iterator[WheelContentElement]:
        for record_elements, stream, is_executable in super().get_contents():
            if not self.should_install(stream.name):
                continue
            yield record_elements, stream, is_executable

    def should_install(self, filename: str) -> bool:
        for install_exclude_glob in self._install_exclude_globs:
            if fnmatch.fnmatch(filename, install_exclude_glob):
                return False
        return True


def main(args: Any) -> None:
    dest_dir = args.directory
    lib_dir = dest_dir / "site-packages"
    destination = SchemeDictionaryDestination(
        scheme_dict={
            "platlib": str(lib_dir),
            "purelib": str(lib_dir),
            "headers": str(dest_dir / "include"),
            "scripts": str(dest_dir / "bin"),
            "data": str(dest_dir / "data"),
        },
        interpreter="/usr/bin/env python3",  # Generic; it's not feasible to run these scripts directly.
        script_kind="posix",
        bytecode_optimization_levels=[],  # Setting to empty list to disable generation of .pyc files.
    )

    link_dir = Path(tempfile.mkdtemp())
    if args.wheel_name_file:
        with open(args.wheel_name_file, "r") as f:
            wheel_name = f.read().strip()
    else:
        wheel_name = os.path.basename(args.wheel)

    link_path = link_dir / wheel_name
    os.symlink(os.path.join(os.getcwd(), args.wheel), link_path)

    try:
        with FilteredWheelFile.open_filtered(link_path, args.install_exclude_globs) as source:
            install(
                source=source,
                destination=destination,
                # Additional metadata that is generated by the installation tool.
                additional_metadata={
                    "INSTALLER": b"https://github.com/jvolkman/rules_pycross",
                },
            )

        if args.cc_hdrs_directory:
            with WheelFile.open(link_path) as source:

                def is_cc_hdr(filename: str) -> bool:
                    for cc_hdrs_glob in args.cc_hdrs_globs:
                        if fnmatch.fnmatch(filename, cc_hdrs_glob):
                            return True
                    return False

                for _, stream, _ in source.get_contents():
                    if is_cc_hdr(stream.name):
                        dest_path = os.path.join(args.cc_hdrs_directory, stream.name)
                        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
                        with open(dest_path, "wb") as dest:
                            shutil.copyfileobj(stream, dest)
    finally:
        shutil.rmtree(link_dir, ignore_errors=True)

    setup_namespace_pkg_compatibility(lib_dir)


def parse_flags() -> Any:
    parser = FlagFileArgumentParser(description="Extract a Python wheel.")

    parser.add_argument(
        "--wheel",
        type=Path,
        required=True,
        help="The wheel file path.",
    )

    parser.add_argument(
        "--wheel-name-file",
        type=Path,
        required=False,
        help="A file containing the canonical name of the wheel.",
    )

    parser.add_argument(
        "--enable-implicit-namespace-pkgs",
        action="store_true",
        help="If true, disables conversion of implicit namespace packages and will unzip as-is.",
    )

    parser.add_argument(
        "--install-exclude-glob",
        action="append",
        dest="install_exclude_globs",
        default=[],
        help="A glob for files to exclude during installation.",
    )

    parser.add_argument(
        "--cc-hdrs-glob",
        action="append",
        dest="cc_hdrs_globs",
        default=[],
        help="A glob for files to use as C/C++ headers.",
    )

    parser.add_argument(
        "--cc-dep",
        action="append",
        dest="cc_deps",
        default=[],
        help="A dependency for C/C++ files.",
    )

    parser.add_argument(
        "--directory",
        type=Path,
        help="The output path.",
    )

    parser.add_argument(
        "--cc-hdrs-directory",
        type=Path,
        help="The C/C++ headers output path.",
    )

    return parser.parse_args()


if __name__ == "__main__":
    # When under `bazel run`, change to the actual working dir.
    if "BUILD_WORKING_DIRECTORY" in os.environ:
        os.chdir(os.environ["BUILD_WORKING_DIRECTORY"])

    main(parse_flags())
